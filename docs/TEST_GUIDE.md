# 软件测试策略指南

## 📖 概述

本文档旨在为 SmartDownloader 项目提供一套清晰、高效的软件测试策略。我们的策略基于业界广泛认可的 **“测试金字塔” (Testing Pyramid)** 模型，旨在通过合理分配不同层次的测试，以最低的成本实现最高的代码质量和项目信心。

---

## 🔺 测试金字塔模型

测试金字塔建议我们将测试分为三个层次，从下到上，测试数量递减，但集成度和用户场景真实性递增。

![测试金字塔](https://martinfowler.com/bliki/images/testPyramid/test-pyramid.png)

1.  **单元测试 (Unit Tests)**: 金字塔的基石，数量最多。
2.  **集成测试 (Integration Tests)**: 中间层，验证模块间的协作。
3.  **端到端测试 (End-to-End Tests)**: 顶层，数量最少，模拟真实用户场景。

---

## 1. 单元测试 (Unit Tests)

这是最底层的测试，也是我们投入精力最多的地方。

*   **🎯 测试角度**: **函数 (Function)** 和 **类 (Class)** 的独立功能。
*   **✅ 目标**: 验证一个最小的功能单元（一个函数或一个类的方法）是否在各种输入下都能按预期工作。它不关心外部依赖（如网络、数据库、文件系统），这些依赖应该被模拟（Mock）。
*   **⚡️ 特点**:
    *   **快**: 运行速度极快，通常在毫秒级别。
    *   **隔离**: 失败时能立刻定位到具体的函数或方法。
    *   **易写**: 依赖少，容易编写和维护。

### 在项目中的应用

*   **`core/format_analyzer.py`**: 这是单元测试的**完美范例**。我们应该为 `_calculate_audio_score`, `_determine_stream_type` 等核心算法函数编写专门的测试，提供各种预设的 `formats` 列表，验证其输出是否符合预期。
*   **`core/command_builder.py`**: 同样是单元测试的绝佳对象。`tests/test_command_builder.py` 已经验证了它能否根据不同输入（如代理、Cookies）正确地构建出命令字符串。
*   **`utils.py`**: `sanitize` 和 `create_simplified_identifier` 这类工具函数，非常适合用单元测试覆盖各种边界情况（如超长字符串、特殊字符、不同平台的URL）。

---

## 2. 集成测试 (Integration Tests)

这一层测试模块与模块之间的协作，确保“积木块”能正确地拼装在一起。

*   **🎯 测试角度**: **模块/服务间的交互**。可以理解为对一个“代码脚本”或一个API端点的测试。
*   **✅ 目标**: 验证当你把几个单元组合在一起时，它们能否正确地协同工作。
*   **⚡️ 特点**:
    *   速度比单元测试慢，但比端到端测试快。
    *   能发现单元测试无法发现的“胶水代码”问题（例如，A模块的输出格式不是B模块期望的输入格式）。

### 在项目中的应用

*   **API 端点测试**: 你的 `tests/test_main_api.py` 就是一个**教科书级别的集成测试**。它使用 `TestClient` 来调用 `/video-info` API，但通过 `patch` 模拟了最外层的依赖（`fetch_video_info_sync`），从而测试了从路由、Pydantic模型验证到内部逻辑调用的整个流程。这是测试后端API的**最佳实践**。
*   **`downloader.py`**: `Downloader` 类是集成测试的重点。它负责编排 `CommandBuilder`, `SubprocessManager`, `FileProcessor` 等多个组件。你应该编写测试来验证它的核心业务流程，例如：
    *   当主策略（一体化下载）失败时，它是否能正确切换到备用策略（分步下载）？
    *   你可以通过模拟（Mock）`_execute_cmd_with_auth_retry` 的返回值来控制流程走向。
*   **`subtitles.py`**: `SubtitleProcessor` 同样适合集成测试。你可以提供一个临时的音频文件，然后模拟 `whisper-cli` 和 `deep_translator` 的外部调用，验证从音频转换、转录到翻译的整个流程是否能正确串联。

---

## 3. 端到端测试 (End-to-End / E2E Tests)

这是最高层次的测试，数量应该最少，但价值最高。

*   **🎯 测试角度**: **完整的用户场景**。从用户界面（或API入口）开始，贯穿整个系统，直到最终结果。
*   **✅ 目标**: 模拟真实用户的操作，验证整个系统（包括前端、后端、数据库、外部服务）是否按预期协同工作。
*   **⚡️ 特点**:
    *   **慢**: 运行非常耗时，因为它需要启动所有服务。
    *   **脆弱**: 任何一个环节（网络、UI变动）出问题都可能导致测试失败。
    *   **高信赖度**: 如果E2E测试通过，你对整个系统的信心是最高的。

### 在项目中的应用

*   你的项目已经有了一个非常棒的E2E测试框架！在 `.github/workflows/tests.yml` 中，`e2e-tests` 作业启动了FastAPI服务器、Celery和Redis，这正是E2E测试所需的环境。
*   你的 `tests/test_audio_debug.py` 文件被 `@pytest.mark.e2e` 标记，它直接向运行中的服务 (`http://localhost:8001`) 发起请求，这是一个**完美的E2E测试用例**。
*   **下一步建议**: 可以使用 `pytest-playwright`（已在依赖中）编写一个测试，模拟真实用户操作：
    1.  打开浏览器访问主页。
    2.  在输入框粘贴一个URL。
    3.  点击“提取视频”按钮。
    4.  断言（Assert）页面上是否出现了预期的格式列表。

---

## 🚀 行动路线：如何选择测试角度？

**不要只选一个角度，而是要合理组合。**

1.  **从底层逻辑开始 (Start from the Bottom-up)**:
    对于核心算法和工具函数（如 `core/format_analyzer.py`, `utils.py`），**从函数/类级别开始编写单元测试**。这是最稳固的基础，能保证你的“积木块”是可靠的。

2.  **从功能入口开始 (Start from the Top-down)**:
    当你开发一个新功能时（比如“添加播放列表支持”），可以先写一个**集成测试**来描述这个功能的API行为。例如，写一个测试用例，调用 `/playlist-info` 端点，并断言它返回了一个视频列表。这个测试一开始会失败，然后你再去实现具体的单元和逻辑，直到这个集成测试通过。这也被称为“测试驱动开发”(TDD)的一种形式。

3.  **为关键流程保驾护航 (Protect the Critical Path)**:
    对于整个应用最重要的用户流程（例如：粘贴URL -> 获取格式 -> 下载视频），保留**少量但关键的E2E测试**。这能确保在代码重构或依赖更新后，核心功能依然完好。

### 总结你的行动路线：

*   **继续加强单元测试**：为你 `core` 目录下的所有模块编写健壮的单元测试。
*   **重点编写集成测试**：为你 `web/main.py` 中的每个API端点编写集成测试，并为 `downloader.py` 和 `subtitles.py` 中的核心业务流程编写集成测试。
*   **精选E2E测试**：维护并扩展你现有的E2E测试，确保覆盖1-2个最核心的用户使用场景。
