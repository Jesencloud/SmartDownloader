# .github/workflows/tests.yml

name: Python Application CI

# 触发器：在推送到主分支或创建拉取请求时运行
on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

# Concurrency control: cancel in-progress runs on the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true


jobs:
  # Job 1: 运行快速的单元测试和不依赖外部服务的集成测试
  unit-tests:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.8", "3.9", "3.10", "3.11"]
    timeout-minutes: 10 # 为作业设置10分钟的超时

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        # 缓存 pip 的下载目录
        path: ~/.cache/pip
        # 缓存的 key，当 requirements.txt 变化时，缓存会失效
        key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-${{ matrix.python-version }}-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run unit and integration tests
      run: |
        pytest --cov=core --cov=web --cov-report=xml -m "not e2e" -v
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }} # 需要在GitHub仓库设置中添加这个secret
        file: ./coverage.xml
        flags: unittests

  # Job 2: 运行需要实时服务的端到端测试
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    # 仅在 unit-tests 成功后运行
    needs: unit-tests
    # 为节省时间，仅在一个 Python 版本上运行 E2E 测试
    timeout-minutes: 15 # 为E2E测试设置更长的超时
    strategy:
      matrix:
        python-version: ["3.11"]

    # 为此作业中的所有步骤设置环境变量
    env:
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND_URL: redis://redis:6379/0

    # 定义此作业所需的服务容器
    services:
      # 'redis' 是服务的主机名
      redis:
        image: redis:6
        # 添加健康检查以确保 Redis 完全启动后再继续
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports: ["6379:6379"]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-${{ matrix.python-version }}-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Install Redis client
      run: |
        sudo apt-get update && sudo apt-get install -y redis-tools

    - name: Prepare yt-dlp for Linux
      run: |
        # Download the Linux binary and place it where the platform-aware
        # application code expects it.
        echo "Downloading yt-dlp for Linux..."
        mkdir -p bin
        curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o bin/yt-dlp_linux
        chmod +x bin/yt-dlp_linux
        echo "✅ yt-dlp for Linux is ready."

    - name: Start Celery worker in background
      run: |
        # 确保 Redis 服务可用
        echo "Waiting for Redis to be available..."
        while ! redis-cli -h localhost ping | grep PONG; do
          echo "Redis not available yet, sleeping..."
          sleep 2
        done
        echo "Redis is up and running!"

        # 启动 Celery worker 并将日志输出到文件，方便调试
        echo "Starting Celery worker..."
        # 为 worker 指定一个明确的主机名，并监听默认的 'celery' 队列，这在CI环境中更可靠
        celery -A web.celery_app worker --loglevel=info --hostname=e2e-worker@%h -Q celery > celery_worker.log 2>&1 &

    - name: Start FastAPI server in background
      run: |
        # 启动 FastAPI 服务器并将日志输出到文件，方便调试
        echo "FastAPI server started. Logs will be in uvicorn.log"
        uvicorn web.main:app --host 0.0.0.0 --port 8000 > uvicorn.log 2>&1 &


        
    - name: Wait for server to be ready
      run: |
        echo "Waiting for server to be ready..."
        # 等待最多30秒，直到服务器的根端点返回成功的HTTP状态码
        # 使用 curl -sSf:
        # -s: silent mode
        # -S: show error even with -s
        # -f: fail silently (no output) on HTTP errors (returns non-zero exit code)
        for i in {1..30}; do
          if curl -sSf http://127.0.0.1:8000/ > /dev/null; then
            echo "✅ FastAPI Server is up and running!"
            exit 0
          fi
          sleep 1
        done
        echo "❌ Server did not become ready in 30 seconds."
        exit 1

    - name: Wait for Celery worker to be ready
      run: |
       set -o pipefail
       echo "Waiting for Celery worker to be responsive..."
       for i in {1..15}; do
         # 使用 'inspect ping' 并增加超时时间。
         # 'set -o pipefail' 确保如果 'celery' 命令失败，整个管道也会失败。
         if celery -A web.celery_app inspect ping --timeout 10 | grep -q "e2e-worker@"; then
           echo "✅ Celery worker is responsive."
           exit 0
         else
           echo "Celery worker not yet responsive (attempt $i/15). Checking logs..."
           tail celery_worker.log  # 打印 Celery worker 的日志
         fi
         sleep 2
       done
        echo "❌ Celery worker did not become ready in 30 seconds."
        echo "--- Final Celery Worker Log ---"
        cat celery_worker.log
        echo "--- Final Ping Attempt ---"
        celery -A web.celery_app inspect ping --timeout 10 # 最后运行一次以显示错误输出并使作业失败
        exit 1

    - name: Run end-to-end tests
      run: |
        # 仅运行标记为 e2e 的测试
        pytest --cov=core --cov=web --cov-report=xml -m "e2e" -v
        
    - name: Upload E2E coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        file: ./coverage.xml
        flags: e2etests # 为E2E测试报告设置一个独立的标志

    - name: 集群信息 (调试)
      if: always()  # 总是执行，用于调试
      run: |
        echo "Celery 集群信息:"
        celery -A web.celery_app status  # 获取 Celery 集群状态
        echo "=========================="
        echo "Redis 信息:"
        redis-cli -h localhost info  # 获取 Redis 信息
