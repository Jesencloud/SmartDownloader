# 更新日志

所有此项目的版本变更都将记录在此文件中。

本项目遵循 [语义化版本](https://semver.org/lang/zh-CN/) 规范。

## [2.3.0] - 2025-07-22
⏺ ✅ Celery 工作进程优化完成！

  现在你可以使用以下几种方式启动和监控 Celery：

  🚀 快速测试 Flower

  现在 Flower 已经正确安装，你可以这样启动：

  # 方法1：使用管理脚本启动 Flower
  python celery_manager.py flower --port 5555

  # 方法2：直接启动 Flower  
  python -m flower -A web.celery_app --port=5555 --basic_auth=admin:admin123

  🛠️ 推荐的启动顺序：

  1. 一键启动所有服务

  python start_all_services.py

  2. 或者分步启动

  # 启动 Worker
  python celery_manager.py start --concurrency 2

  # 启动监控 (二选一)
  python celery_manager.py flower --port 5555           # Flower (功能全)
  python celery_manager.py builtin-monitor --port 8001  # 内置监控 (轻量)

  # 启动 Web 服务
  python -m uvicorn web.main:app --host 0.0.0.0 --port 8000 --reload

  📊 监控界面访问：

  - Web 服务: http://localhost:8000
  - Flower 监控: http://localhost:5555 (用户名: admin, 密码: admin123)
  - 内置监控: http://localhost:8001
  - 命令行监控: python celery_manager.py monitor

  🎯 核心优化改进：

  1. 智能超时控制 - 防止任务无限挂起
  2. 资源监控 - 实时检查内存、CPU、磁盘
  3. 自动重试 - 网络错误时自动恢复
  4. 队列分离 - 下载和维护任务分离
  5. 进程管理 - 定期重启防止内存泄漏
  6. 双监控方案 - Flower + 内置监控备选

  这套优化方案将显著提升 Celery 的性能、稳定性和可监控性！🎉


😄


  修复的问题

  用户点击"返回主页"取消下载后，uvicorn后台仍然会打印对/downloads/{task_id}的轮询请求。

  根本原因

  前端的pollTaskStatus函数中的setInterval定时器没有在用户取消下载时被正确清除，导致轮询持续进行。

  解决方案

  1. 正确存储intervalId: 在setInterval创建后立即将ID存储到DOM元素的data-polling-interval属性中
  2. 增强取消机制: 在handleReturnHome函数中清除所有活跃的轮询定时器
  3. 双重检查机制: 在轮询函数内部添加取消状态检查，防止已取消的轮询继续执行fetch请求
  4. 完整的资源清理: 确保Celery任务取消、进程终止和文件清理都正常工作

  现在系统的取消机制是完整和可靠的：
  - ✅ 前端轮询立即停止
  - ✅ 后端任务正确取消
  - ✅ 子进程被强制终止
  - ✅ 临时文件得到清理
  - ✅ 不再有残留的HTTP请求

---

问题核心
这个问题的核心是一个经典的前端难题：如何在动态更新页面部分内容的同时，不破坏或中断页面上其他部分的状态，尤其是正在进行的CSS动画。

我们最初的尝试之所以失败，都是因为直接或间接地触发了浏览器的重绘（Repaint）或重排（Reflow），这个过程在某些环境下会重置CSS动画。

经验总结
innerHTML 是“毁灭性”的，而非“更新性”的

初期方案: 我们尝试过保存下载项的 innerHTML，重绘整个列表，再把保存的内容写回去。
教训: 这个方法失败了，因为它从根本上销毁了原来的DOM元素，再创建一个新的。即使内容看起来一样，对于浏览器来说，这是一个全新的元素，它的所有状态（包括CSS动画的播放进度）都丢失了。
DOM操作的“涟漪效应”

中期方案: 我们尝试了更精确的方法，只更新那些没有在下载的兄弟元素。
教训: 这个方法依然失败，说明了DOM操作的复杂性。即使我们没有直接触碰正在动画的元素，但修改了它的父元素或兄弟元素，也可能导致浏览器需要重新计算整个容器的布局（Reflow），这个“涟漪效应”足以中断子元素的动画。
“物理隔离”是最终的制胜法宝（我们最终的成功方案）

最终方案: 我们不再把静态内容和动态动画放在同一个可被替换的容器里。我们为每个下载项创建了两个独立的div：一个用于静态内容 (.option-content)，一个用作动画占位符 (.option-progress)。
为什么成功:
当下载开始时，我们做的不是替换内容，而是切换可见性：隐藏内容div，显示动画div。
当切换语言时，我们的更新逻辑只修改内容div里的文本。由于动画div是一个完全独立的兄弟元素，并且此时内容div甚至是隐藏的，所以对内容div的任何操作都完全不会影响到正在播放动画的div。
这就像是在一个盒子里有两个独立的小隔间，我们只在其中一个隔间里整理东西，另一个隔间里的东西（我们的动画）因此安然无恙。
用CSS类进行状态管理

贯穿始终的最佳实践: 使用一个CSS类（如 .is-downloading）来标记元素的状态，这是一个非常清晰和高效的方法。它让我们的JavaScript逻辑可以非常简单地识别出哪些元素是“不可触碰”的，从而保护它们。
最终的成功策略回顾
HTML结构分离: 每个下载选项内部都包含 .option-content 和 .option-progress 两个并列的容器。
用可见性切换状态: 下载开始时，隐藏前者，显示后者。
精准、微创的更新: 语言切换时，只更新 .option-content 内部的文本，绝不触碰 .option-progress。
状态恢复: 下载结束后，隐藏 .option-progress，将结果（成功/失败）写回 .option-content 并重新显示它。

### Changed
- **重构视频下载逻辑**: 引入了先进的“主/备 (Primary/Fallback)”策略，优先尝试高效的一体化下载，失败后自动切换到分步下载与合并，显著提高下载成功率。
- **重构音频下载逻辑**: 采用双策略方法，根据请求类型智能选择：
    - 对格式转换请求（如 MP3），使用与视频下载一致的“主动指定”策略。
    - 对直接下载原始流的请求，使用更可靠的“主动搜索”策略。

### Added
- **实现“主动验证”策略**: 对于视频下载和音频格式转换，程序现在会预先构建确切的输出路径并进行验证，取代了旧的搜索方式，判断更快速、更可靠。
- **实现“主动搜索”策略**: 对于直接下载的音频流，程序现在会根据已知的文件名前缀进行精确搜索，避免了在整个目录中盲目查找的问题。

### Improved
- **提升健壮性**: 新的下载策略能更好地应对各种下载场景和潜在的失败情况。
- **代码清晰度**: `Downloader` 模块的职责更加明确，作为总指挥，编排 `CommandBuilder`、`SubprocessManager` 等核心模块，提升了代码的可维护性。
