# downloader.py

import asyncio
import json
import logging
import re
import random
import socket
import time
from pathlib import Path
from typing import Optional, List, Generator, Dict, Any, AsyncGenerator

import aiofiles
from rich.console import Console
from rich.progress import (Progress, BarColumn, TextColumn, TimeRemainingColumn,
                           DownloadColumn, TransferSpeedColumn, TaskID)

from config_manager import config

log = logging.getLogger(__name__)
console = Console()

# --- Custom Exceptions ---
class DownloaderException(Exception):
    """‰∏ãËΩΩÂô®Ê®°ÂùóÁöÑÂü∫Á°ÄÂºÇÂ∏∏„ÄÇ"""
    pass

class MaxRetriesExceededException(DownloaderException):
    """ÂΩìÊìç‰ΩúÂú®ÊâÄÊúâÈáçËØïÂêé‰ªçÁÑ∂Â§±Ë¥•Êó∂ÊäõÂá∫„ÄÇ"""
    pass

class NetworkException(DownloaderException):
    """ÈíàÂØπÂèØËÉΩÊòØ‰∏¥Êó∂ÊÄßÁöÑÁΩëÁªúÁõ∏ÂÖ≥ÈîôËØØ„ÄÇ"""
    pass

class ProxyException(NetworkException):
    """ÈíàÂØπ‰ª£ÁêÜÁâπÂÆöÁöÑËøûÊé•ÈîôËØØ„ÄÇ"""
    pass

class DownloadStalledException(NetworkException):
    """ÂΩì‰∏ãËΩΩ‰ºº‰πéÂÅúÊªûÊó∂ÊäõÂá∫„ÄÇ"""
    pass

class NonRecoverableErrorException(DownloaderException):
    """ÈíàÂØπ‰∏çÂ∫îÈáçËØïÁöÑÈîôËØØÔºå‰æãÂ¶Ç 404 Not Found„ÄÇ"""
    def __init__(self, message, details=""):
        super().__init__(message)
        self.details = details

class FFmpegException(DownloaderException):
    """ÂΩì ffmpeg Â§ÑÁêÜÊñá‰ª∂Â§±Ë¥•Êó∂ÊäõÂá∫„ÄÇ"""
    pass

# --- Circuit Breaker States ---
from enum import Enum

class CircuitBreakerState(Enum):
    CLOSED = "CLOSED"
    OPEN = "OPEN"
    HALF_OPEN = "HALF_OPEN"

# --- End of Custom Exceptions ---


class Downloader:
    def __init__(self, download_folder: Path, cookies_file: Optional[str] = None, proxy: Optional[str] = None):
        self.download_folder = download_folder
        self.cookies_file = cookies_file
        self.proxy = proxy

        # ‰ªé Pydantic Ê®°ÂûãÁõ¥Êé•Ëé∑ÂèñÈÖçÁΩÆ
        self.max_retries = config.downloader.max_retries
        self.base_delay = config.downloader.base_delay
        self.max_delay = config.downloader.max_delay
        self.backoff_factor = config.downloader.backoff_factor
        self.network_timeout = config.downloader.network_timeout
        self.stall_detection_time = config.downloader.stall_detection_time
        self.stall_check_interval = config.downloader.stall_check_interval
        self.stall_threshold_count = config.downloader.stall_threshold_count
        self.proxy_retry_base_delay = config.downloader.proxy_retry_base_delay
        self.proxy_retry_increment = config.downloader.proxy_retry_increment
        self.proxy_retry_max_delay = config.downloader.proxy_retry_max_delay

        self.connectivity_test_host = config.advanced.connectivity_test_host
        self.connectivity_test_port = config.advanced.connectivity_test_port
        self.connectivity_timeout = config.advanced.connectivity_timeout
        self.proxy_test_url = config.advanced.proxy_test_url
        self.proxy_test_timeout = config.advanced.proxy_test_timeout

        self.circuit_breaker_failure_threshold = config.downloader.circuit_breaker_failure_threshold
        self.circuit_breaker_timeout = config.downloader.circuit_breaker_timeout

        # Circuit Breaker state
        self._circuit_breaker_state = CircuitBreakerState.CLOSED
        self._failure_count = 0
        self._last_failure_timestamp = 0

        console.print(f"üîÑ ÈáçËØïÊú∫Âà∂Â∑≤ÂêØÁî®: ÊúÄÂ§ö {self.max_retries} Ê¨°ÈáçËØïÔºåÂü∫Á°ÄÂª∂Ëøü {self.base_delay}s", style="bold blue")
        console.print(f"üåê ÁΩëÁªú‰∏≠Êñ≠Â§ÑÁêÜ: Â∞ÜÊåÅÁª≠ÈáçËØïÁõ¥Âà∞ÁΩëÁªúÊÅ¢Â§çÔºàÊúÄÂ§ö50Ê¨°Ôºâ", style="bold cyan")

    async def _check_network_connectivity(self) -> bool:
        """ÂºÇÊ≠•ÁöÑÁΩëÁªúËøûÊé•Ê£ÄÊü•"""
        try:
            await asyncio.wait_for(
                asyncio.open_connection(self.connectivity_test_host, self.connectivity_test_port),
                timeout=self.connectivity_timeout
            )
            return True
        except (OSError, asyncio.TimeoutError):
            return False

    def _calculate_delay(self, attempt: int) -> int:
        """ËÆ°ÁÆóÊåáÊï∞ÈÄÄÈÅøÂª∂ËøüÊó∂Èó¥"""
        delay = self.base_delay * (self.backoff_factor ** attempt)
        jitter = random.uniform(0.5, 1.5)
        delay = min(delay * jitter, self.max_delay)
        return int(delay)

    def _should_retry(self, error_output: str) -> bool:
        error_lower = error_output.lower()
        return any(re.search(p.lower(), error_lower) for p in config.downloader.retry_patterns)

    def _is_proxy_error(self, error_output: str) -> bool:
        error_lower = error_output.lower()
        return any(p.lower() in error_lower for p in config.downloader.proxy_patterns)

    def _check_circuit_breaker(self):
        """Ê£ÄÊü•ÁÜîÊñ≠Âô®Áä∂ÊÄÅÔºåÂπ∂Ê†πÊçÆÈúÄË¶ÅËΩ¨Êç¢Áä∂ÊÄÅ„ÄÇ"""
        if self._circuit_breaker_state == CircuitBreakerState.OPEN:
            elapsed_time = time.time() - self._last_failure_timestamp
            if elapsed_time > self.circuit_breaker_timeout:
                self._circuit_breaker_state = CircuitBreakerState.HALF_OPEN
                log.info("ÁÜîÊñ≠Âô®‰ªé OPEN ËΩ¨Êç¢‰∏∫ HALF-OPEN Áä∂ÊÄÅ„ÄÇ")
            else:
                raise DownloaderException("ÁÜîÊñ≠Âô®Â§Ñ‰∫é OPEN Áä∂ÊÄÅÔºåÂø´ÈÄüÂ§±Ë¥•„ÄÇ")
        elif self._circuit_breaker_state == CircuitBreakerState.HALF_OPEN:
            log.info("ÁÜîÊñ≠Âô®Â§Ñ‰∫é HALF-OPEN Áä∂ÊÄÅÔºåÂÖÅËÆ∏‰∏ÄÊ¨°Â∞ùËØï„ÄÇ")

    def _record_failure(self):
        """ËÆ∞ÂΩï‰∏ÄÊ¨°Â§±Ë¥•ÔºåÂπ∂Ê†πÊçÆÈòàÂÄºËΩ¨Êç¢ÁÜîÊñ≠Âô®Áä∂ÊÄÅ„ÄÇ"""
        self._failure_count += 1
        if self._circuit_breaker_state == CircuitBreakerState.HALF_OPEN:
            self._circuit_breaker_state = CircuitBreakerState.OPEN
            self._last_failure_timestamp = time.time()
            self._failure_count = 0  # Reset failure count for OPEN state
            log.warning("ÁÜîÊñ≠Âô®‰ªé HALF-OPEN ËΩ¨Êç¢‰∏∫ OPEN Áä∂ÊÄÅ„ÄÇ")
        elif self._circuit_breaker_state == CircuitBreakerState.CLOSED and self._failure_count >= self.circuit_breaker_failure_threshold:
            self._circuit_breaker_state = CircuitBreakerState.OPEN
            self._last_failure_timestamp = time.time()
            log.warning(f"ËøûÁª≠Â§±Ë¥• {self._failure_count} Ê¨°ÔºåÁÜîÊñ≠Âô®‰ªé CLOSED ËΩ¨Êç¢‰∏∫ OPEN Áä∂ÊÄÅ„ÄÇ")

    def _reset_circuit_breaker(self):
        """ÈáçÁΩÆÁÜîÊñ≠Âô®Âà∞ CLOSED Áä∂ÊÄÅ„ÄÇ"""
        if self._circuit_breaker_state != CircuitBreakerState.CLOSED:
            log.info("ÁÜîÊñ≠Âô®ÈáçÁΩÆ‰∏∫ CLOSED Áä∂ÊÄÅ„ÄÇ")
        self._circuit_breaker_state = CircuitBreakerState.CLOSED
        self._failure_count = 0
        self._last_failure_timestamp = 0

    def _build_base_yt_dlp_cmd(self) -> List[str]:
        cmd = ['yt-dlp', '--ignore-config', '--no-warnings']
        if self.proxy: cmd.extend(['--proxy', self.proxy])
        if self.cookies_file:
            cmd.extend(['--cookies', str(Path(self.cookies_file).resolve())])
        return cmd

    async def _execute_subprocess_with_retries(self, cmd: List[str], stdout_pipe: Any, stderr_pipe: Any) -> asyncio.subprocess.Process:
        attempt = 0
        while attempt <= self.max_retries:
            self._check_circuit_breaker()
            process = None
            try:
                if attempt > 0:
                    delay = self._calculate_delay(attempt - 1)
                    console.print(f"‚ôæÔ∏è Á¨¨ {attempt + 1} Ê¨°Â∞ùËØïÔºåÁ≠âÂæÖ {delay} Áßí...", style="bold yellow")
                    await asyncio.sleep(delay)

                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=stdout_pipe,
                    stderr=stderr_pipe
                )
                
                # For mypy type narrowing
                if stdout_pipe == asyncio.subprocess.PIPE:
                    assert process.stdout is not None
                if stderr_pipe == asyncio.subprocess.PIPE:
                    assert process.stderr is not None

                log.info(f"Â≠êËøõÁ®ãÊàêÂäüÂàõÂª∫: {cmd[0]}")
                return process

            except (DownloadStalledException, ProxyException, NetworkException) as e:
                log.warning(f"Êìç‰Ωú‰∏≠ÈÅáÂà∞ÈóÆÈ¢ò: {e}", exc_info=True)
                self._record_failure()
                if process and process.returncode is None: process.kill()
                
                attempt += 1
                if attempt > self.max_retries:
                    raise MaxRetriesExceededException(f"Êìç‰ΩúÂú® {self.max_retries + 1} Ê¨°Â∞ùËØïÂêéÂ§±Ë¥•„ÄÇ")
                continue

            except KeyboardInterrupt:
                if process and process.returncode is None: process.kill()
                raise
            except Exception as e:
                log.error(f"Êú™Áü•Â≠êËøõÁ®ãÈîôËØØ: {e}", exc_info=True)
                if process and process.returncode is None: process.kill()
                raise DownloaderException(f"Êú™Áü•Â≠êËøõÁ®ãÈîôËØØ: {e}")

        raise MaxRetriesExceededException(f"Êìç‰ΩúÂú® {self.max_retries + 1} Ê¨°Â∞ùËØïÂêéÂ§±Ë¥•„ÄÇ")

    async def stream_playlist_info(self, url: str) -> AsyncGenerator[Dict[str, Any], None]:
        cmd = self._build_base_yt_dlp_cmd() + ['--flat-playlist', '--print-json', '--skip-download', url]
        limit = 2 * 1024 * 1024 # 2MB limit
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            limit=limit
        )

        if process.stdout is None:
            log.error(f"Êó†Ê≥ïËé∑Âèñ {url} ÁöÑ stdout ÊµÅ„ÄÇ")
            return

        while True:
            line = await process.stdout.readline()
            if not line:
                break
            try:
                yield json.loads(line)
            except json.JSONDecodeError:
                continue

        retcode = await process.wait()
        if retcode != 0:
            error = b""
            if process.stderr is not None:
                error = await process.stderr.read()
            log.error(f"Ëß£ÊûêURL '{url}' Êó∂Âá∫Èîô: {error.decode()}")

    async def download_and_merge(self, video_url: str, file_prefix: str) -> Path:
        video_part_base, audio_part_base = f"{file_prefix}_video.tmp", f"{file_prefix}_audio.tmp"

        with Progress(
            TextColumn("[bold blue]‚¨áÔ∏è {task.description}"), BarColumn(bar_width=None),
            "[progress.percentage]{task.percentage:>3.1f}%", "|", DownloadColumn(), "|",
            TransferSpeedColumn(), "|", TimeRemainingColumn(), console=console, expand=True
        ) as progress:
            console.print("üì• Ê≠£Âú®‰∏ãËΩΩËßÜÈ¢ëÈÉ®ÂàÜ...", style="bold green")
            video_task = progress.add_task("‰∏ãËΩΩËßÜÈ¢ë", total=100)
            vid_cmd = self._build_base_yt_dlp_cmd() + ['-f', 'bestvideo[ext=mp4]/bestvideo',
                     '--newline', '-o', f"{self.download_folder / video_part_base}.%(ext)s", video_url]
            await self._run_subprocess_with_progress(vid_cmd, progress, video_task)

            console.print("üîä Ê≠£Âú®‰∏ãËΩΩÈü≥È¢ëÈÉ®ÂàÜ...", style="bold green")
            audio_task = progress.add_task("‰∏ãËΩΩÈü≥È¢ë", total=100)
            aud_cmd = self._build_base_yt_dlp_cmd() + ['-f', 'bestaudio[ext=m4a]/bestaudio',
                     '--newline', '-o', f"{self.download_folder / audio_part_base}.%(ext)s", video_url]
            await self._run_subprocess_with_progress(aud_cmd, progress, audio_task)

            vid_part = next(self.download_folder.glob(f"{video_part_base}.*"), None)
            aud_part = next(self.download_folder.glob(f"{audio_part_base}.*"), None)

            if not (vid_part and aud_part):
                merged_file = next((p for p in self.download_folder.glob(f"{file_prefix}.*") if p.suffix in ['.mp4', '.mkv', '.webm']), None)
                if merged_file:
                    console.print("‚úÖ Ê£ÄÊµãÂà∞Â™í‰ΩìÊ∫êÂ∑≤ÂêàÂπ∂", style="bold green")
                    return merged_file
                raise NonRecoverableErrorException("Êú™ÊâæÂà∞‰∏ãËΩΩÁöÑËßÜÈ¢ëÊàñÈü≥È¢ëÊñá‰ª∂")

            console.print("‚úÖ ËßÜÈ¢ë/Èü≥È¢ë‰∏ãËΩΩÂÆåÊàê", style="bold green")

        return await self.merge_to_mp4(vid_part, aud_part, file_prefix)

    async def merge_to_mp4(self, video_part: Path, audio_part: Path, file_prefix: str) -> Path:
        console.print("üîß Ê≠£Âú®ÂêàÂπ∂ËßÜÈ¢ëÂíåÈü≥È¢ë...", style="bold yellow")
        final_path = self.download_folder / f"{file_prefix}.mp4"
        cmd = ['ffmpeg', '-y', '-i', str(video_part.resolve()), '-i', str(audio_part.resolve()),
               '-c', 'copy', str(final_path.resolve())]

        try:
            await self._run_subprocess(cmd, True)
            console.print(f"‚úÖ ËßÜÈ¢ëÂêàÂπ∂ÊàêÂäü: {final_path.name}", style="bold green")
            return final_path
        except Exception as e:
            raise FFmpegException(f"ËßÜÈ¢ëÂêàÂπ∂Â§±Ë¥•: {e}")

    async def download_metadata(self, url: str, file_prefix: str) -> None:
        cmd = self._build_base_yt_dlp_cmd() + ['--skip-download', '--write-info-json', '--write-thumbnail',
                                             '--convert-thumbnails', 'png', '-o', str(self.download_folder / file_prefix), url]
        await self._run_subprocess(cmd)

    async def extract_audio_from_local_file(self, video_path: Path, file_prefix: str) -> Path:
        console.print(f"üé• Ê≠£Âú®ÊèêÂèñÈü≥È¢ë: {video_path.name}", style="bold blue")
        mp3_path = self.download_folder / f"{file_prefix}.mp3"
        cmd = ['ffmpeg','-y', '-i', str(video_path.resolve()),'-vn','-q:a', '0', str(mp3_path.resolve())]

        try:
            await self._run_subprocess(cmd, True)
            console.print(f"‚úÖ Èü≥È¢ëÊèêÂèñÊàêÂäü: {mp3_path.name}", style="bold green")
            return mp3_path
        except Exception as e:
            raise FFmpegException(f"Èü≥È¢ëÊèêÂèñÂ§±Ë¥•: {e}")

    async def cleanup_temp_files(self, file_prefix: str) -> None:
        # Using asyncio.to_thread for synchronous glob and unlink
        loop = asyncio.get_running_loop()
        def _cleanup():
            for p in self.download_folder.glob(f"{file_prefix}.f*"): p.unlink(missing_ok=True)
            for p in self.download_folder.glob(f"{file_prefix}_*.tmp.*"): p.unlink(missing_ok=True)
        await loop.run_in_executor(None, _cleanup)


    async def cleanup_all_incomplete_files(self) -> None:
        patterns = config.file_processing.cleanup_patterns
        cleaned_files = []
        
        def _cleanup():
            for pattern in patterns:
                for file_path in self.download_folder.glob(pattern):
                    try:
                        file_path.unlink()
                        cleaned_files.append(file_path.name)
                    except Exception as e:
                        log.error(f"Ê∏ÖÁêÜÊñá‰ª∂ {file_path.name} Â§±Ë¥•: {e}")
        
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, _cleanup)

        if cleaned_files:
            console.print(f"üßπ Â∑≤Ê∏ÖÁêÜ {len(cleaned_files)} ‰∏™Êú™ÂÆåÊàêÊñá‰ª∂", style="bold yellow")

    async def _run_subprocess_with_progress(self, cmd: List[str], progress: Progress, task_id: TaskID) -> None:
        process = await self._execute_subprocess_with_retries(cmd, asyncio.subprocess.PIPE, asyncio.subprocess.STDOUT)

        error_output = ""
        last_progress_time = time.time()

        while True:
            if process.stdout is None:
                break
            try:
                line_bytes = await asyncio.wait_for(process.stdout.readline(), self.network_timeout)
                if not line_bytes:
                    break
                
                line = line_bytes.decode('utf-8', errors='ignore')
                error_output += line
                last_progress_time = time.time()

                if '[download]' in line and '%' in line:
                    percent_match = re.search(r'(\d+\.\d+)%', line)
                    if percent_match:
                        percentage = float(percent_match.group(1))
                        progress.update(task_id, completed=percentage)
            
            except asyncio.TimeoutError:
                raise DownloadStalledException(f"‰∏ãËΩΩË∂ÖÊó∂ ({self.network_timeout}s Êó†ËøõÂ∫¶Êõ¥Êñ∞)")

        retcode = await process.wait()
        if retcode == 0:
            progress.update(task_id, completed=progress.tasks[task_id].total or 100)
            self._reset_circuit_breaker() # Reset circuit breaker on success
            return

        if process.stderr is None:
            error_output = ""
        else:
            error_output = (await process.stderr.read()).decode('utf-8', errors='ignore')

        if self._is_proxy_error(error_output):
            raise ProxyException(f"‰ª£ÁêÜËøûÊé•Â§±Ë¥•: {error_output[:200]}")
        elif self._should_retry(error_output):
            raise NetworkException(f"ÂèØÈáçËØïÁöÑÁΩëÁªúÈîôËØØ: {error_output[:200]}")
        else:
            raise NonRecoverableErrorException("ÂèëÁîü‰∏çÂèØÈáçËØïÁöÑÈîôËØØ", details=error_output)

    async def _run_subprocess(self, cmd: List[str], capture_output: bool = False) -> None:
        process = await self._execute_subprocess_with_retries(cmd, asyncio.subprocess.PIPE, asyncio.subprocess.PIPE)
        stdout, stderr = await process.communicate()

        if process.returncode == 0:
            self._reset_circuit_breaker() # Reset circuit breaker on success
            return

        if stderr is None:
            error_output = ""
        else:
            error_output = stderr.decode('utf-8', errors='ignore')

        if self._is_proxy_error(error_output):
            raise ProxyException(f"‰ª£ÁêÜËøûÊé•Â§±Ë¥•: {error_output[:200]}")
        elif self._should_retry(error_output):
            raise NetworkException(f"ÂèØÈáçËØïÁöÑÁΩëÁªúÈîôËØØ: {error_output[:200]}")
        else:
            raise DownloaderException(f"ÂëΩ‰ª§ '{cmd[0]}' ÊâßË°åÂ§±Ë¥•: {error_output}")