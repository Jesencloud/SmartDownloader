# subtitles.py

import time
import re
from pathlib import Path
from typing import Optional, Dict

# å°è¯•å¯¼å…¥AIç›¸å…³çš„åº“
try:
    import whisper
    from deep_translator import GoogleTranslator
    AI_LIBRARIES_AVAILABLE = True
except ImportError:
    AI_LIBRARIES_AVAILABLE = False

class SubtitleProcessor:
    """
    è´Ÿè´£æ‰€æœ‰ä¸AIå­—å¹•ç”Ÿæˆç›¸å…³çš„ä»»åŠ¡ã€‚
    ã€å·²æ›´æ–°ã€‘ï¼šæ”¯æŒé€šè¿‡ä»£ç†è¿›è¡Œç¿»è¯‘ã€‚
    """
    def __init__(self, download_folder: Path, proxy: Optional[str] = None):
        if not AI_LIBRARIES_AVAILABLE:
            raise ImportError("å¿…è¦çš„AIåº“ï¼ˆopenai-whisper æˆ– deep-translatorï¼‰æœªå®‰è£…ã€‚")
        
        self.download_folder = download_folder
        self.whisper_model = None
        
        # ã€æ–°ã€‘å°†ä»£ç†å­—ç¬¦ä¸²è½¬æ¢ä¸º deep-translator éœ€è¦çš„å­—å…¸æ ¼å¼
        proxy_dict: Optional[Dict[str, str]] = None
        if proxy:
            # å‡è®¾ http å’Œ https éƒ½èµ°åŒä¸€ä¸ªä»£ç†
            proxy_dict = {"http": proxy, "https": proxy}
        
        # åœ¨åˆå§‹åŒ–æ—¶ä¼ å…¥ä»£ç†
        self.translator = GoogleTranslator(source='en', target='zh-CN', proxies=proxy_dict)

    # ... a _check_for_existing_subs, _transcribe, _translate, _merge ...
    # (å…¶ä½™æ‰€æœ‰æ–¹æ³•æ— éœ€æ”¹åŠ¨)
    def process_item(self, file_prefix: str, audio_source_path: Path) -> None:
        """å¤„ç†å•ä¸ªé¡¹ç›®AIå­—å¹•ç”Ÿæˆçš„å®Œæ•´æµç¨‹ã€‚"""
        print("\n" + "-" * 25)
        print("  ğŸ§  AIå­—å¹•ç”Ÿæˆæµç¨‹å¯åŠ¨...")
        
        if self._check_for_existing_subs(file_prefix):
            return

        en_srt_path = self._transcribe(audio_source_path)
        if en_srt_path:
            zh_srt_path = self._translate(en_srt_path)
            if zh_srt_path:
                self._merge(en_srt_path, zh_srt_path)

    def _check_for_existing_subs(self, file_prefix: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å®˜æ–¹å­—å¹•ã€‚"""
        existing_subs = list(self.download_folder.glob(f"{file_prefix}*.srt"))
        if existing_subs:
            print(f"    â„¹ï¸ æ£€æµ‹åˆ°å·²ä¸‹è½½çš„å®˜æ–¹å­—å¹• ({[sub.name for sub in existing_subs]})ï¼Œè·³è¿‡AIç”Ÿæˆã€‚")
            return True
        return False
        
    def _transcribe(self, audio_path: Path) -> Optional[Path]:
        """ä½¿ç”¨ Whisper è¿›è¡Œè¯­éŸ³è½¬å½•ã€‚"""
        print(f"    ğŸ¤ [Whisper] æ­£åœ¨ä» '{audio_path.name}' è½¬å½•è‹±æ–‡è¯­éŸ³ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´...")
        try:
            if not self.whisper_model:
                print("    é¦–æ¬¡åŠ è½½Whisperæ¨¡å‹ (base.en)...")
                self.whisper_model = whisper.load_model("base.en")
            
            result = self.whisper_model.transcribe(str(audio_path), verbose=False, language='en')
            srt_path = audio_path.with_suffix('.en.srt')
            
            with open(srt_path, "w", encoding="utf-8") as f:
                for i, segment in enumerate(result['segments']):
                    start, end, text = segment['start'], segment['end'], segment['text']
                    start_time = f"{int(start//3600):02d}:{int(start%3600//60):02d}:{int(start%60):02d},{int(start*1000%1000):03d}"
                    end_time = f"{int(end//3600):02d}:{int(end%3600//60):02d}:{int(end%60):02d},{int(end*1000%1000):03d}"
                    f.write(f"{i + 1}\n{start_time} --> {end_time}\n{text.strip()}\n\n")
            
            print(f"    âœ… [Whisper] è‹±æ–‡SRTå­—å¹•å·²ç”Ÿæˆ: {srt_path.name}")
            return srt_path
        except Exception as e:
            print(f"    âŒ [Whisper] è¯­éŸ³è½¬å½•å¤±è´¥: {e}")
            return None

    def _translate(self, srt_path_in: Path) -> Optional[Path]:
        """ä½¿ç”¨ deep-translator è¿›è¡Œæ‰¹é‡ç¿»è¯‘ã€‚"""
        print(f"    âœï¸ [Translator] æ­£åœ¨ä½¿ç”¨ deep-translator (Google) ç¿»è¯‘ '{srt_path_in.name}'...")
        srt_path_out = srt_path_in.with_suffix('.zh-CN.srt')
        try:
            with open(srt_path_in, 'r', encoding='utf-8') as f_in:
                content = f_in.read()

            text_blocks = [m.group(1) for m in re.finditer(r'\d+\n[\d:,->\s]+\n(.*?)\n\n', content, re.DOTALL)]
            delimiter = "\n<br>\n"
            full_text = delimiter.join(text.replace('\n', ' ') for text in text_blocks)
            translated_full_text = self.translator.translate(full_text)
            
            # å¦‚æœç¿»è¯‘ç»“æœä¸ºç©ºï¼Œåˆ™å¯èƒ½å‡ºé”™äº†
            if not translated_full_text:
                raise ValueError("ç¿»è¯‘æœåŠ¡è¿”å›äº†ç©ºç»“æœã€‚")

            translated_blocks = translated_full_text.split(delimiter.strip())

            if len(text_blocks) != len(translated_blocks):
                raise ValueError(f"ç¿»è¯‘è¿”å›ç‰‡æ®µæ•°({len(translated_blocks)})ä¸åŸæ–‡({len(text_blocks)})ä¸åŒ¹é…ã€‚")

            it_translated = iter(translated_blocks)
            def replace_func(match): return next(it_translated).strip()
            new_content = re.sub(r'(\d+\n[\d:,->\s]+\n)(.+?)(\n\n)', lambda m: m.group(1) + replace_func(m.group(2)) + m.group(3), content, flags=re.DOTALL)
            
            with open(srt_path_out, 'w', encoding='utf-8') as f_out:
                f_out.write(new_content)

            print(f"    âœ… [Translator] ä¸­æ–‡SRTå­—å¹•å·²ç”Ÿæˆ: {srt_path_out.name}")
            return srt_path_out
        except Exception as e:
            print(f"    âŒ [Translator] ç¿»è¯‘å¤±è´¥: {e}")
            return None

    def _merge(self, en_srt_path: Path, zh_srt_path: Path) -> Optional[Path]:
        """åˆå¹¶ä¸­è‹±æ–‡å­—å¹•ã€‚"""
        print(f"    ğŸ¤ [Merger] æ­£åœ¨åˆå¹¶å­—å¹•...")
        bilingual_srt_path = en_srt_path.with_suffix('.bilingual.srt')
        try:
            with open(en_srt_path, 'r', encoding='utf-8') as f: en_content = f.read()
            with open(zh_srt_path, 'r', encoding='utf-8') as f: zh_content = f.read()
            en_subs = {m.group(1): m.group(3).strip() for m in re.finditer(r'(\d+)\n([\d:,->\s]+)\n(.*?)\n\n', en_content, re.DOTALL)}
            zh_subs = {m.group(1): m.group(3).strip() for m in re.finditer(r'(\d+)\n([\d:,->\s]+)\n(.*?)\n\n', zh_content, re.DOTALL)}
            timestamps = {m.group(1): m.group(2).strip() for m in re.finditer(r'(\d+)\n([\d:,->\s]+\n)', en_content)}
            
            with open(bilingual_srt_path, 'w', encoding='utf-8') as f_out:
                for index, timestamp in timestamps.items():
                    f_out.write(f"{index}\n")
                    f_out.write(f"{timestamp}\n")
                    f_out.write(f"{zh_subs.get(index, '')}\n")
                    f_out.write(f"{en_subs.get(index, '')}\n\n")
            
            print(f"    âœ… [Merger] åŒè¯­SRTå­—å¹•å·²ç”Ÿæˆ: {bilingual_srt_path.name}")
            return bilingual_srt_path
        except Exception as e:
            print(f"    âŒ [Merger] å­—å¹•åˆå¹¶å¤±è´¥: {e}")
            return None